Q1:
Overall there are no estimated task in this project. The underestimated one was the part that I have to use code to generate code. This is because I have never done anything like this before and when I read about it I thought this would be the most trivial part of this project. However I was wrong. This took 1/2 ~ 1/3 time of this whole project. I had to write all the code I already wrote into Strings with some extra if-else and while-loops making it even harder.
From my past experience I think the hardest tasks to estimate are the ones with unfamiliar logics and also the ones with familiar but easy-to-make-mistake logics. For me, in this project there are not a lot of unfamiliar logics and as a result I think I've done a relative good job estimating the time I would use for each task. The code-generate-code part was not very logic-heavy but just simply tedious and was a challenge to my concentration and will power. One thing I would definitely underestimate every single time is the linked-list. I make all kinds of mistakes about linked-lists and despite my best effort to keep my code and logic as clear as possible, strange bugs keep coming to me and it usually takes me a lot more time to debug a linked-list task than I would expect.
Logic-wise unfamiliar or easy-to-make-mistake make it harder to estimate a task mainly because the bugs usually hide in all kinds of corners that one could not expect. Thus how long it will take to debug them will halfly depend on experience and halfly depend on luck. But when it comes to a logic that I am very familiar with, no matter how comlex it inherently is, I would tend to write the correct code quickly. This is because for those code, I have formed some sort of "regime" and no much think would be needed to write the code. This is somewhat alike to the "design patterns", where already-established good patterns help people write code both quickly and correctly.

Q2:
In my opinion I have managed to meet my immediate deadlines quite well, thanks to the fact that I am not unfamiliar with the idea of serialization and deserialization, and the fact that saving objects into hashmaps and avoid dependency cycles are also not a very hard problem for me by now. Also, I took large chunk of time focusing on this project instead of mixing everything up, which definitely had its downfalls but also helped me focus on one thing at a time.

Q3:
Q3.1:
For my code, changing the generated language to other langugages would only require new implementation of the interface CodeEngine, like CppCodeEngine, or PythonCodeEngine, then injecting them into ClassBuilder class, and the core code in ClassBuilderHelper would not need to be changed at all. This is because from the very beginning my code was designed in the way that other languages could be plug-and-play with it. Basically, the ClassBuilderHelper depends only on the interface, CodeEngine, and in ClassBuilder, you inject any language engine implementation you want into ClassBuilderHelper and it would be done. This obeys the Open/Closed Principle and the Dependency Inversion Principle.

Q3.2:
During the time I wrote the code for this project, I did not take XML input format into consideration. However, due to the similarity between XML and JSON, I think it is entirely possible to only write an adapter (which is a design pattern recently covered in ece651), which could convert between JSON and XML format and plug it in all the places where a JSON input/output is needed, and this project's code would not need to be changed at all.

Q3.3:
Again when doing serialization/deserialization, we just need that XML_JSON adapter to be used on the input/output of the already exsited functions' methods, all internal logics will still be performed on JSON, only the io format will be changed by the adapter.

Q4:
I don't have too much regret for my design currently. One thing I would probably change would be to add an extra layer of abstraction in the code generator and seperate the language-specific implementation further from the project, so that when a new langugae generater would to be implemented, even less code is needed.

The singleton design pattern works really well for all the generated classes with all their fields type set to private and getter/setter methods set to public to access/modify them. Also, the adapter pattern would be really useful if we want to make this project XML-compatible, since with a XML-JSON adapter we can easily take in XML but still do the processing in json format.

Also, the DRY principle helps me keep the code as clean and maintainable as possible. I also paid attention to obey the Open/Close Principle and Dependency Inversion Principle by making class builder only dependent on the code generater interface and then implement java code generator sperately, leaving flexibility for future expension to be compatible with more languages as reqruied.


Q5:
I only started this project this Monday. Thanks to the fact that multi-dimensional arrays were set to be extra-credits intead of being inside the project and the fact that I started 568 & 650 projects early and finished them before I started this one, I have managed to finish this project just in time. However, one thing I have learnt is that next time I should start from the very beginning, instead of feeling free and happy at first and worried and tired in the end. Time flies by faster than I could imagine when I decided to not study and took my time a little. I would definitely start everything earlier in both my future study and career.
Another thing I've learnt is that even something is not is in the requirement, if it seems like a good idea, than I should probably do it. In this project, at the very beginning I knew that the generated code would not be graded by their format, but I chose to format them nicely with great attention to '\t's and '\n's, and the resulting code turned out to be almost exactly the same as the original hand-written prototype that I have tested thoroughly, which saved me a lot of time looking for code mismatch and debugging it.
Also, in the future, especially in my career, I would pay more attention to possible change of requirement and try to keep my code as flexible and extensible as possible. This is the kind of technical debt I will always avoid to have in the beginning.
